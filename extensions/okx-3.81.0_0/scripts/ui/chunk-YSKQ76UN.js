import{k as Zt}from"./chunk-C5XO4JMZ.js";import{c as Nt,o as lt,q as dt}from"./chunk-Y5OH3DDZ.js";var Jt=Nt(d=>{lt();dt();Object.defineProperty(d,"__esModule",{value:!0});d.utils=d.schnorr=d.verify=d.signSync=d.sign=d.getSharedSecret=d.recoverPublicKey=d.getPublicKey=d.Signature=d.Point=d.CURVE=void 0;var Ct=Zt(),w=BigInt(0),E=BigInt(1),k=BigInt(2),L=BigInt(3),yt=BigInt(8),p=Object.freeze({a:w,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:E,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});d.CURVE=p;var wt=(n,t)=>(n+t/k)/t,j={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(n){let{n:t}=p,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-E*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=e,o=BigInt("0x100000000000000000000000000000000"),c=wt(i*n,t),u=wt(-r*n,t),a=f(n-c*e-u*s,t),h=f(-c*r-u*i,t),l=a>o,y=h>o;if(l&&(a=t-a),y&&(h=t-h),a>o||h>o)throw new Error("splitScalarEndo: Endomorphism failed, k="+n);return{k1neg:l,k1:a,k2neg:y,k2:h}}},I=32,C=32,bt=32,nt=I+1,rt=2*I+1;function gt(n){let{a:t,b:e}=p,r=f(n*n),s=f(r*n);return f(s+t*n+e)}var Q=p.a===w,M=class extends Error{constructor(t){super(t)}};function mt(n){if(!(n instanceof m))throw new TypeError("JacobianPoint expected")}var m=class{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static fromAffine(t){if(!(t instanceof g))throw new TypeError("JacobianPoint#fromAffine: expected Point");return t.equals(g.ZERO)?m.ZERO:new m(t.x,t.y,E)}static toAffineBatch(t){let e=Dt(t.map(r=>r.z));return t.map((r,s)=>r.toAffine(e[s]))}static normalizeZ(t){return m.toAffineBatch(t).map(m.fromAffine)}equals(t){mt(t);let{x:e,y:r,z:s}=this,{x:i,y:o,z:c}=t,u=f(s*s),a=f(c*c),h=f(e*a),l=f(i*u),y=f(f(r*c)*a),S=f(f(o*s)*u);return h===l&&y===S}negate(){return new m(this.x,f(-this.y),this.z)}double(){let{x:t,y:e,z:r}=this,s=f(t*t),i=f(e*e),o=f(i*i),c=t+i,u=f(k*(f(c*c)-s-o)),a=f(L*s),h=f(a*a),l=f(h-k*u),y=f(a*(u-l)-yt*o),S=f(k*e*r);return new m(l,y,S)}add(t){mt(t);let{x:e,y:r,z:s}=this,{x:i,y:o,z:c}=t;if(i===w||o===w)return this;if(e===w||r===w)return t;let u=f(s*s),a=f(c*c),h=f(e*a),l=f(i*u),y=f(f(r*c)*a),S=f(f(o*s)*u),x=f(l-h),B=f(S-y);if(x===w)return B===w?this.double():m.ZERO;let O=f(x*x),P=f(x*O),V=f(h*O),_=f(B*B-P-k*V),ft=f(B*(V-_)-y*P),W=f(s*c*x);return new m(_,ft,W)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){let e=m.ZERO;if(typeof t=="bigint"&&t===w)return e;let r=xt(t);if(r===E)return this;if(!Q){let l=e,y=this;for(;r>w;)r&E&&(l=l.add(y)),y=y.double(),r>>=E;return l}let{k1neg:s,k1:i,k2neg:o,k2:c}=j.splitScalar(r),u=e,a=e,h=this;for(;i>w||c>w;)i&E&&(u=u.add(h)),c&E&&(a=a.add(h)),h=h.double(),i>>=E,c>>=E;return s&&(u=u.negate()),o&&(a=a.negate()),a=new m(f(a.x*j.beta),a.y,a.z),u.add(a)}precomputeWindow(t){let e=Q?128/t+1:256/t+1,r=[],s=this,i=s;for(let o=0;o<e;o++){i=s,r.push(i);for(let c=1;c<2**(t-1);c++)i=i.add(s),r.push(i);s=i.double()}return r}wNAF(t,e){!e&&this.equals(m.BASE)&&(e=g.BASE);let r=e&&e._WINDOW_SIZE||1;if(256%r)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let s=e&&at.get(e);s||(s=this.precomputeWindow(r),e&&r!==1&&(s=m.normalizeZ(s),at.set(e,s)));let i=m.ZERO,o=m.BASE,c=1+(Q?128/r:256/r),u=2**(r-1),a=BigInt(2**r-1),h=2**r,l=BigInt(r);for(let y=0;y<c;y++){let S=y*u,x=Number(t&a);t>>=l,x>u&&(x-=h,t+=E);let B=S,O=S+Math.abs(x)-1,P=y%2!==0,V=x<0;x===0?o=o.add(J(P,s[B])):i=i.add(J(V,s[O]))}return{p:i,f:o}}multiply(t,e){let r=xt(t),s,i;if(Q){let{k1neg:o,k1:c,k2neg:u,k2:a}=j.splitScalar(r),{p:h,f:l}=this.wNAF(c,e),{p:y,f:S}=this.wNAF(a,e);h=J(o,h),y=J(u,y),y=new m(f(y.x*j.beta),y.y,y.z),s=h.add(y),i=l.add(S)}else{let{p:o,f:c}=this.wNAF(r,e);s=o,i=c}return m.normalizeZ([s,i])[0]}toAffine(t){let{x:e,y:r,z:s}=this,i=this.equals(m.ZERO);t==null&&(t=i?yt:F(s));let o=t,c=f(o*o),u=f(c*o),a=f(e*c),h=f(r*u),l=f(s*o);if(i)return g.ZERO;if(l!==E)throw new Error("invZ was invalid");return new g(a,h)}};m.BASE=new m(p.Gx,p.Gy,E);m.ZERO=new m(w,E,w);function J(n,t){let e=t.negate();return n?e:t}var at=new WeakMap,g=class{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,at.delete(this)}hasEvenY(){return this.y%k===w}static fromCompressedHex(t){let e=t.length===32,r=v(e?t:t.subarray(1));if(!et(r))throw new Error("Point is not on curve");let s=gt(r),i=Vt(s),o=(i&E)===E;e?o&&(i=f(-i)):(t[0]&1)===1!==o&&(i=f(-i));let c=new g(r,i);return c.assertValidity(),c}static fromUncompressedHex(t){let e=v(t.subarray(1,I+1)),r=v(t.subarray(I+1,I*2+1)),s=new g(e,r);return s.assertValidity(),s}static fromHex(t){let e=R(t),r=e.length,s=e[0];if(r===I)return this.fromCompressedHex(e);if(r===nt&&(s===2||s===3))return this.fromCompressedHex(e);if(r===rt&&s===4)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-${nt} compressed bytes or ${rt} uncompressed bytes, not ${r}`)}static fromPrivateKey(t){return g.BASE.multiply($(t))}static fromSignature(t,e,r){let{r:s,s:i}=At(e);if(![0,1,2,3].includes(r))throw new Error("Cannot recover: invalid recovery bit");let o=ut(R(t)),{n:c}=p,u=r===2||r===3?s+c:s,a=F(u,c),h=f(-o*a,c),l=f(i*a,c),y=r&1?"03":"02",S=g.fromHex(y+T(u)),x=g.BASE.multiplyAndAddUnsafe(S,h,l);if(!x)throw new Error("Cannot recover signature: point at infinify");return x.assertValidity(),x}toRawBytes(t=!1){return N(this.toHex(t))}toHex(t=!1){let e=T(this.x);return t?`${this.hasEvenY()?"02":"03"}${e}`:`04${e}${T(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){let t="Point is not on elliptic curve",{x:e,y:r}=this;if(!et(e)||!et(r))throw new Error(t);let s=f(r*r),i=gt(e);if(f(s-i)!==w)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new g(this.x,f(-this.y))}double(){return m.fromAffine(this).double().toAffine()}add(t){return m.fromAffine(this).add(m.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return m.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,r){let s=m.fromAffine(this),i=e===w||e===E||this!==g.BASE?s.multiplyUnsafe(e):s.multiply(e),o=m.fromAffine(t).multiplyUnsafe(r),c=i.add(o);return c.equals(m.ZERO)?void 0:c.toAffine()}};d.Point=g;g.BASE=new g(p.Gx,p.Gy);g.ZERO=new g(w,w);function pt(n){return Number.parseInt(n[0],16)>=8?"00"+n:n}function Et(n){if(n.length<2||n[0]!==2)throw new Error(`Invalid signature integer tag: ${K(n)}`);let t=n[1],e=n.subarray(2,t+2);if(!t||e.length!==t)throw new Error("Invalid signature integer: wrong length");if(e[0]===0&&e[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:v(e),left:n.subarray(t+2)}}function $t(n){if(n.length<2||n[0]!=48)throw new Error(`Invalid signature tag: ${K(n)}`);if(n[1]!==n.length-2)throw new Error("Invalid signature: incorrect length");let{data:t,left:e}=Et(n.subarray(2)),{data:r,left:s}=Et(e);if(s.length)throw new Error(`Invalid signature: left bytes after parsing: ${K(s)}`);return{r:t,s:r}}var H=class{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){let e=t instanceof Uint8Array,r="Signature.fromCompact";if(typeof t!="string"&&!e)throw new TypeError(`${r}: Expected string or Uint8Array`);let s=e?K(t):t;if(s.length!==128)throw new Error(`${r}: Expected 64-byte hex`);return new H(st(s.slice(0,64)),st(s.slice(64,128)))}static fromDER(t){let e=t instanceof Uint8Array;if(typeof t!="string"&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");let{r,s}=$t(e?t:N(t));return new H(r,s)}static fromHex(t){return this.fromDER(t)}assertValidity(){let{r:t,s:e}=this;if(!X(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!X(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){let t=p.n>>E;return this.s>t}normalizeS(){return this.hasHighS()?new H(this.r,f(-this.s,p.n)):this}toDERRawBytes(){return N(this.toDERHex())}toDERHex(){let t=pt(Y(this.s)),e=pt(Y(this.r)),r=t.length/2,s=e.length/2,i=Y(r),o=Y(s);return`30${Y(s+r+4)}02${o}${e}02${i}${t}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return N(this.toCompactHex())}toCompactHex(){return T(this.r)+T(this.s)}};d.Signature=H;function z(...n){if(!n.every(r=>r instanceof Uint8Array))throw new Error("Uint8Array list expected");if(n.length===1)return n[0];let t=n.reduce((r,s)=>r+s.length,0),e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){let i=n[r];e.set(i,s),s+=i.length}return e}var Ot=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function K(n){if(!(n instanceof Uint8Array))throw new Error("Expected Uint8Array");let t="";for(let e=0;e<n.length;e++)t+=Ot[n[e]];return t}var Pt=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function T(n){if(typeof n!="bigint")throw new Error("Expected bigint");if(!(w<=n&&n<Pt))throw new Error("Expected number 0 <= n < 2^256");return n.toString(16).padStart(64,"0")}function q(n){let t=N(T(n));if(t.length!==32)throw new Error("Error: expected 32 bytes");return t}function Y(n){let t=n.toString(16);return t.length&1?`0${t}`:t}function st(n){if(typeof n!="string")throw new TypeError("hexToNumber: expected string, got "+typeof n);return BigInt(`0x${n}`)}function N(n){if(typeof n!="string")throw new TypeError("hexToBytes: expected string, got "+typeof n);if(n.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+n.length);let t=new Uint8Array(n.length/2);for(let e=0;e<t.length;e++){let r=e*2,s=n.slice(r,r+2),i=Number.parseInt(s,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");t[e]=i}return t}function v(n){return st(K(n))}function R(n){return n instanceof Uint8Array?Uint8Array.from(n):N(n)}function xt(n){if(typeof n=="number"&&Number.isSafeInteger(n)&&n>0)return BigInt(n);if(typeof n=="bigint"&&X(n))return n;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function f(n,t=p.P){let e=n%t;return e>=w?e:t+e}function A(n,t){let{P:e}=p,r=n;for(;t-- >w;)r*=r,r%=e;return r}function Vt(n){let{P:t}=p,e=BigInt(6),r=BigInt(11),s=BigInt(22),i=BigInt(23),o=BigInt(44),c=BigInt(88),u=n*n*n%t,a=u*u*n%t,h=A(a,L)*a%t,l=A(h,L)*a%t,y=A(l,k)*u%t,S=A(y,r)*y%t,x=A(S,s)*S%t,B=A(x,o)*x%t,O=A(B,c)*B%t,P=A(O,o)*x%t,V=A(P,L)*a%t,_=A(V,i)*S%t,ft=A(_,e)*u%t,W=A(ft,k);if(W*W%t!==n)throw new Error("Cannot find square root");return W}function F(n,t=p.P){if(n===w||t<=w)throw new Error(`invert: expected positive integers, got n=${n} mod=${t}`);let e=f(n,t),r=t,s=w,i=E,o=E,c=w;for(;e!==w;){let a=r/e,h=r%e,l=s-o*a,y=i-c*a;r=e,e=h,s=o,i=c,o=l,c=y}if(r!==E)throw new Error("invert: does not exist");return f(s,t)}function Dt(n,t=p.P){let e=new Array(n.length),r=n.reduce((i,o,c)=>o===w?i:(e[c]=i,f(i*o,t)),E),s=F(r,t);return n.reduceRight((i,o,c)=>o===w?i:(e[c]=f(i*e[c],t),f(i*o,t)),s),e}function Kt(n){let t=n.length*8-C*8,e=v(n);return t>0?e>>BigInt(t):e}function ut(n,t=!1){let e=Kt(n);if(t)return e;let{n:r}=p;return e>=r?e-r:e}var D,G,it=class{constructor(t,e){if(this.hashLen=t,this.qByteLen=e,typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(t).fill(1),this.k=new Uint8Array(t).fill(0),this.counter=0}hmac(...t){return d.utils.hmacSha256(this.k,...t)}hmacSync(...t){return G(this.k,...t)}checkSync(){if(typeof G!="function")throw new M("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),t.length!==0&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),t.length!==0&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){this.incr();let t=0,e=[];for(;t<this.qByteLen;){this.v=await this.hmac(this.v);let r=this.v.slice();e.push(r),t+=this.v.length}return z(...e)}generateSync(){this.checkSync(),this.incr();let t=0,e=[];for(;t<this.qByteLen;){this.v=this.hmacSync(this.v);let r=this.v.slice();e.push(r),t+=this.v.length}return z(...e)}};function X(n){return w<n&&n<p.n}function et(n){return w<n&&n<p.P}function vt(n,t,e,r=!0){let{n:s}=p,i=ut(n,!0);if(!X(i))return;let o=F(i,s),c=g.BASE.multiply(i),u=f(c.x,s);if(u===w)return;let a=f(o*f(t+e*u,s),s);if(a===w)return;let h=new H(u,a),l=(c.x===h.r?0:2)|Number(c.y&E);return r&&h.hasHighS()&&(h=h.normalizeS(),l^=1),{sig:h,recovery:l}}function $(n){let t;if(typeof n=="bigint")t=n;else if(typeof n=="number"&&Number.isSafeInteger(n)&&n>0)t=BigInt(n);else if(typeof n=="string"){if(n.length!==2*C)throw new Error("Expected 32 bytes of private key");t=st(n)}else if(n instanceof Uint8Array){if(n.length!==C)throw new Error("Expected 32 bytes of private key");t=v(n)}else throw new TypeError("Expected valid private key");if(!X(t))throw new Error("Expected private key: 0 < key < n");return t}function ht(n){return n instanceof g?(n.assertValidity(),n):g.fromHex(n)}function At(n){if(n instanceof H)return n.assertValidity(),n;try{return H.fromDER(n)}catch{return H.fromCompact(n)}}function qt(n,t=!1){return g.fromPrivateKey(n).toRawBytes(t)}d.getPublicKey=qt;function Xt(n,t,e,r=!1){return g.fromSignature(n,t,e).toRawBytes(r)}d.recoverPublicKey=Xt;function St(n){let t=n instanceof Uint8Array,e=typeof n=="string",r=(t||e)&&n.length;return t?r===nt||r===rt:e?r===nt*2||r===rt*2:n instanceof g}function Ft(n,t,e=!1){if(St(n))throw new TypeError("getSharedSecret: first arg must be private key");if(!St(t))throw new TypeError("getSharedSecret: second arg must be public key");let r=ht(t);return r.assertValidity(),r.multiply($(n)).toRawBytes(e)}d.getSharedSecret=Ft;function Bt(n){let t=n.length>I?n.slice(0,I):n;return v(t)}function Wt(n){let t=Bt(n),e=f(t,p.n);return It(e<w?t:e)}function It(n){return q(n)}function Ht(n,t,e){if(n==null)throw new Error(`sign: expected valid message hash, not "${n}"`);let r=R(n),s=$(t),i=[It(s),Wt(r)];if(e!=null){e===!0&&(e=d.utils.randomBytes(I));let u=R(e);if(u.length!==I)throw new Error(`sign: Expected ${I} bytes of extra data`);i.push(u)}let o=z(...i),c=Bt(r);return{seed:o,m:c,d:s}}function Rt(n,t){let{sig:e,recovery:r}=n,{der:s,recovered:i}=Object.assign({canonical:!0,der:!0},t),o=s?e.toDERRawBytes():e.toCompactRawBytes();return i?[o,r]:o}async function Yt(n,t,e={}){let{seed:r,m:s,d:i}=Ht(n,t,e.extraEntropy),o=new it(bt,C);await o.reseed(r);let c;for(;!(c=vt(await o.generate(),s,i,e.canonical));)await o.reseed();return Rt(c,e)}d.sign=Yt;function Lt(n,t,e={}){let{seed:r,m:s,d:i}=Ht(n,t,e.extraEntropy),o=new it(bt,C);o.reseedSync(r);let c;for(;!(c=vt(o.generateSync(),s,i,e.canonical));)o.reseedSync();return Rt(c,e)}d.signSync=Lt;var Gt={strict:!0};function Mt(n,t,e,r=Gt){let s;try{s=At(n),t=R(t)}catch{return!1}let{r:i,s:o}=s;if(r.strict&&s.hasHighS())return!1;let c=ut(t),u;try{u=ht(e)}catch{return!1}let{n:a}=p,h=F(o,a),l=f(c*h,a),y=f(i*h,a),S=g.BASE.multiplyAndAddUnsafe(u,l,y);return S?f(S.x,a)===i:!1}d.verify=Mt;function ot(n){return f(v(n),p.n)}var Z=class{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){let e=R(t);if(e.length!==64)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`);let r=v(e.subarray(0,32)),s=v(e.subarray(32,64));return new Z(r,s)}assertValidity(){let{r:t,s:e}=this;if(!et(t)||!X(e))throw new Error("Invalid signature")}toHex(){return T(this.r)+T(this.s)}toRawBytes(){return N(this.toHex())}};function _t(n){return g.fromPrivateKey(n).toRawX()}var ct=class{constructor(t,e,r=d.utils.randomBytes()){if(t==null)throw new TypeError(`sign: Expected valid message, not "${t}"`);this.m=R(t);let{x:s,scalar:i}=this.getScalar($(e));if(this.px=s,this.d=i,this.rand=R(r),this.rand.length!==32)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(t){let e=g.fromPrivateKey(t),r=e.hasEvenY()?t:p.n-t;return{point:e,scalar:r,x:e.toRawX()}}initNonce(t,e){return q(t^v(e))}finalizeNonce(t){let e=f(v(t),p.n);if(e===w)throw new Error("sign: Creation of signature failed. k is zero");let{point:r,x:s,scalar:i}=this.getScalar(e);return{R:r,rx:s,k:i}}finalizeSig(t,e,r,s){return new Z(t.x,f(e+r*s,p.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){let{m:t,d:e,px:r,rand:s}=this,i=d.utils.taggedHash,o=this.initNonce(e,await i(U.aux,s)),{R:c,rx:u,k:a}=this.finalizeNonce(await i(U.nonce,o,r,t)),h=ot(await i(U.challenge,u,r,t)),l=this.finalizeSig(c,a,h,e);return await kt(l,t,r)||this.error(),l}calcSync(){let{m:t,d:e,px:r,rand:s}=this,i=d.utils.taggedHashSync,o=this.initNonce(e,i(U.aux,s)),{R:c,rx:u,k:a}=this.finalizeNonce(i(U.nonce,o,r,t)),h=ot(i(U.challenge,u,r,t)),l=this.finalizeSig(c,a,h,e);return Tt(l,t,r)||this.error(),l}};async function jt(n,t,e){return new ct(n,t,e).calc()}function Qt(n,t,e){return new ct(n,t,e).calcSync()}function Ut(n,t,e){let r=n instanceof Z,s=r?n:Z.fromHex(n);return r&&s.assertValidity(),{...s,m:R(t),P:ht(e)}}function zt(n,t,e,r){let s=g.BASE.multiplyAndAddUnsafe(t,$(e),f(-r,p.n));return!(!s||!s.hasEvenY()||s.x!==n)}async function kt(n,t,e){try{let{r,s,m:i,P:o}=Ut(n,t,e),c=ot(await d.utils.taggedHash(U.challenge,q(r),o.toRawX(),i));return zt(r,o,s,c)}catch{return!1}}function Tt(n,t,e){try{let{r,s,m:i,P:o}=Ut(n,t,e),c=ot(d.utils.taggedHashSync(U.challenge,q(r),o.toRawX(),i));return zt(r,o,s,c)}catch(r){if(r instanceof M)throw r;return!1}}d.schnorr={Signature:Z,getPublicKey:_t,sign:jt,verify:kt,signSync:Qt,verifySync:Tt};g.BASE._setWindowSize(8);var b={node:Ct,web:typeof self=="object"&&"crypto"in self?self.crypto:void 0},U={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},tt={};d.utils={bytesToHex:K,hexToBytes:N,concatBytes:z,mod:f,invert:F,isValidPrivateKey(n){try{return $(n),!0}catch{return!1}},_bigintTo32Bytes:q,_normalizePrivateKey:$,hashToPrivateKey:n=>{n=R(n);let t=C+8;if(n.length<t||n.length>1024)throw new Error("Expected valid bytes of private key as per FIPS 186");let e=f(v(n),p.n-E)+E;return q(e)},randomBytes:(n=32)=>{if(b.web)return b.web.getRandomValues(new Uint8Array(n));if(b.node){let{randomBytes:t}=b.node;return Uint8Array.from(t(n))}else throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>d.utils.hashToPrivateKey(d.utils.randomBytes(C+8)),precompute(n=8,t=g.BASE){let e=t===g.BASE?t:new g(t.x,t.y);return e._setWindowSize(n),e.multiply(L),e},sha256:async(...n)=>{if(b.web){let t=await b.web.subtle.digest("SHA-256",z(...n));return new Uint8Array(t)}else if(b.node){let{createHash:t}=b.node,e=t("sha256");return n.forEach(r=>e.update(r)),Uint8Array.from(e.digest())}else throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(n,...t)=>{if(b.web){let e=await b.web.subtle.importKey("raw",n,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),r=z(...t),s=await b.web.subtle.sign("HMAC",e,r);return new Uint8Array(s)}else if(b.node){let{createHmac:e}=b.node,r=e("sha256",n);return t.forEach(s=>r.update(s)),Uint8Array.from(r.digest())}else throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(n,...t)=>{let e=tt[n];if(e===void 0){let r=await d.utils.sha256(Uint8Array.from(n,s=>s.charCodeAt(0)));e=z(r,r),tt[n]=e}return d.utils.sha256(e,...t)},taggedHashSync:(n,...t)=>{if(typeof D!="function")throw new M("sha256Sync is undefined, you need to set it");let e=tt[n];if(e===void 0){let r=D(Uint8Array.from(n,s=>s.charCodeAt(0)));e=z(r,r),tt[n]=e}return D(e,...t)},_JacobianPoint:m};Object.defineProperties(d.utils,{sha256Sync:{configurable:!1,get(){return D},set(n){D||(D=n)}},hmacSha256Sync:{configurable:!1,get(){return G},set(n){G||(G=n)}}})});export{Jt as a};
//# sourceMappingURL=chunk-YSKQ76UN.js.map
