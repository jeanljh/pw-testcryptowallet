import{a as p}from"./chunk-WP6BSXIA.js";import{a as f}from"./chunk-S367OKY5.js";import{c as l,f as w}from"./chunk-RLY3NWVP.js";import"./chunk-U3KULTRT.js";import{d as v,e as m}from"./chunk-55T2IW2N.js";import{a as T}from"./chunk-WVUOJIBP.js";import{b as i,c as y}from"./chunk-JBROAQ6E.js";import"./chunk-LBCITKCK.js";import"./chunk-LVJGLJNA.js";import"./chunk-5F7M5EJ4.js";import{o as g,q as C}from"./chunk-Y5OH3DDZ.js";g();C();var A=class extends f{constructor({supportChain:t}){super(),this.chainType=i.EVM,this.chainMap={},this.supportChain=t&&t.length>0?t:[i.EVM,i.SOLANA,i.APTOS,i.TRON,i.SUI,i.BTC,i.FRACTAL,i.BTCSIGNET,i.STACKS,i.STARKNET,i.NOSTR,i.COSMOS,i.TON,i.SONIC_DEV],this.initPromise=this.init(),this.aptos={},this.cosmos={}}async init(){let t=this.supportChain.includes(i.SOLANA)?(await import("./Solana-VZJ2YUE4.js")).default:{},e=this.supportChain.includes(i.APTOS)?(await import("./Aptos-IZ3C6NUU.js")).default:{},n=this.supportChain.includes(i.TRON)?(await import("./Tron-FWV2ELWH.js")).default:{},a=this.supportChain.includes(i.SUI)?(await import("./Sui-WOXQU7VD.js")).default:{},r=this.supportChain.includes(i.BTC)?(await import("./Btc-HQQOZB7K.js")).default:{},s=this.supportChain.includes(i.FRACTAL)?(await import("./Fractal-GKAYEYIB.js")).default:{},o=this.supportChain.includes(i.BTCSIGNET)?(await import("./BtcSignet-ILCYSDN2.js")).default:{},c=this.supportChain.includes(i.STACKS)?(await import("./Stacks-AUU7AAAC.js")).default:{},u=this.supportChain.includes(i.STARKNET)?(await import("./Starknet-XP7E5THO.js")).default:{},h=this.supportChain.includes(i.NOSTR)?(await import("./Nostr-KOKYTHUC.js")).default:{},d=this.supportChain.includes(i.COSMOS)?(await import("./Cosmos-A47R3OU6.js")).default:{},S=this.supportChain.includes(i.TON)?(await import("./Ton-6LAVRYMV.js")).default:{},M=this.supportChain.includes(i.SONIC_DEV)?(await import("./SonicDev-OKJDIORX.js")).default:{};this.chainMap={[i.SOLANA]:{...t},[i.APTOS]:{...e},[i.TRON]:{...n},[i.SUI]:{...a},[i.BTC]:{...r},[i.FRACTAL]:{...s},[i.BTCSIGNET]:{...o},[i.STACKS]:{...c},[i.STARKNET]:{...u},[i.NOSTR]:{...h},[i.TON]:{...S},[i.SONIC_DEV]:{...M},[i.COSMOS]:d},this.aptos=e,this.cosmos=d}chainMethodMap(t){return this.chainMap[t]||{...p}}async getOkxConnectProvider(t){let e=t||t===i.BTC?t:this.chainType,n=await l();return e===i.EVM?new Web3(n?.ethereum):n}async getWeb3(){let t=await this.getOkxConnectProvider();return this.chainType===i.EVM?t:t[y[this.chainType]]}async getAccount(){let t=this.chainMethodMap(this.chainType).getAccount,e=await this.getOkxConnectProvider();return await t({provider:e})}async getAccountByChainId({chainId:t,chainType:e}){let n=e||e===i.BTC?e:w(t),a=this.chainMethodMap(n).getAccount,r=await this.getOkxConnectProvider(n);try{return await a({provider:r,chainId:t})}catch(s){return console.log("getAccountByChainId err:",s),""}}async signMessage({nonce:t,message:e}){let n=await this.getOkxConnectProvider(),a=await this.getAccount(),r=this.chainMethodMap(this.chainType).signMessage;try{return await r({provider:n,message:e,nonce:t,address:a})}catch(s){throw console.log("signMessage err:",s),s}}async signTypedData({message:t,...e}){let n=await this.getAccount();return await(await l())?.ethereum?.request({method:"eth_signTypedData_v4",params:[n,JSON.stringify(t)],...e})}async getChainId(){if(this.chainType===i.EVM){let t=await this.getOkxConnectProvider(),e=await p.getChainId({provider:t});return await m(e)}else if(this.chainType===i.COSMOS)return this.cosmos.getChainId();return this.chainType}async switchNetwork({chain:t,externalProvider:e,addNetworkConfig:n}){let a=await v(t),r=await l(),s=e||r?.ethereum;try{let o=await this.getChainId();return String(o)===String(a)||await s.request({method:"wallet_switchEthereumChain",params:[{chainId:`0x${parseInt(a).toString(16)}`}]}),!0}catch(o){console.log("metamask switch error",o);let{code:c,data:u}=o||{};if(c!==-32002)if([4902,-32602].includes(c)||u?.originalError?.code===4902)try{if(!a&&a!==0)throw new Error("chain parameter is not legal");let h=n||(await T(a))?.data||[];if(h.length>0){await s.request({method:"wallet_addEthereumChain",params:h});let d=await this.getChainId();return String(d)===String(a)}throw new Error("chain info is not exist")}catch(h){return console.log(h),!1}else return c===4001,!1}return!1}async sendTransaction({payload:t,cb:e,extraParams:n}){let a=await this.getOkxConnectProvider(),r=this.chainMethodMap(this.chainType).sendTransaction,s=await this.getAccount();return r({provider:a,payload:t,cb:e,extraParams:n,address:s})}async setChainType({chainType:t,chainId:e}){let n=t||t==0?t:w(e);!!await this.getAccountByChainId({chainId:e,chainType:n})?this.chainType=n:n===i.COSMOS&&this.cosmos.setChainId(e)}async signAllTransactions({transactions:t}){let e=await this.getOkxConnectProvider(),n=this.chainMethodMap(this.chainType).signAllTransactions;if(!n)throw new Error("current chain have no signAllTransactions, please check it");return await n({provider:e,transactions:t})}getSolanaConnection(){let t=this.chainMethodMap(this.chainType).getSolanaConnection;if(!t)throw new Error("current chain have no getSolanaConnection, please check it");return t()}async depositWToken({wTokenAddr:t,wTokenAbi:e,amount:n,cb:a}){let r=await this.getAccount(),s=await this.getWeb3(),o=p.depositWToken({wTokenAddr:t,wTokenAbi:e,amount:n,account:r,web3:s});return this.sendTransaction({payload:o,cb:a})}async withdrawWToken({wTokenAddr:t,wTokenAbi:e,amount:n,cb:a}){let r=await this.getAccount(),s=await this.getWeb3(),o=p.withdrawWToken({wTokenAddr:t,wTokenAbi:e,amount:n,account:r,web3:s});return this.sendTransaction({payload:o,cb:a})}async getLatestBlockhash(){let t=await this.getAccount(),e=this.chainMethodMap(this.chainType).getLatestBlockhash;if(!e)throw new Error("current chain have no getLatestBlockhash, please check it");return await e({from:t})}async getAllChainTypeInfoList(){let t=await this.getAccount(),e=await this.getChainId();return[{address:t,chainType:this.chainType,chainId:e}]}async watchAsset({tokenOptions:t}){let n=(await l())?.ethereum;return await p.watchAsset({provider:n,tokenOptions:t})}async addNetwork({params:t}){let n=(await l())?.ethereum;return await p.addNetwork({provider:n,params:t})}async registerAptosCoin({contractAddress:t}){return this.aptos.registerAptosCoin({contractAddress:t,provider:window.okexchain})}async checkAndRegAptosCoin({address:t,contractAddress:e}){return this.aptos.checkAndRegAptosCoin({provider:window.okexchain,address:t,contractAddress:e})}async getAptosBalance({address:t,currency:e}){return this.aptos.getAptosBalance({address:t,currency:e})}async getAptosTransaction(t){return this.aptos.getAptosTransaction(t)}async getPublicKey(){let t=await this.getOkxConnectProvider(),e=this.chainMethodMap(this.chainType).getPublicKey;if(!e)throw new Error("current chain have no getPublicKey, please check it");return e({provider:t})}async getCompressedPublicKey(){let t=await this.getOkxConnectProvider(),e=this.chainMethodMap(this.chainType).getCompressedPublicKey;if(!e)throw new Error("current chain have no getCompressedPublicKey, please check it");return e({provider:t})}async sendInscription({from:t,to:e,data:n,type:a}){let r=await this.getOkxConnectProvider(),s=this.chainMethodMap(this.chainType).sendInscription;if(!s)throw new Error("current chain have no sendInscription, please check it");return await s({provider:r,from:t,to:e,data:n,type:a})}async signPsbt({psbtHex:t,type:e,...n}){let a=await this.getOkxConnectProvider(),r=await this.getAccount(),s=this.chainMethodMap(this.chainType).signPsbt;if(!s)throw new Error("current chain have no signPsbt, please check it");return s({provider:a,psbtHex:t,type:e,account:r,...n})}async sendPsbt({txList:t}){let e=await this.getOkxConnectProvider(),n=await this.getAccount(),a=this.chainMethodMap(this.chainType).sendPsbt;if(!a)throw new Error("current chain have no sendPsbt, please check it");return await a({provider:e,txList:t,account:n})}async signPsbts({psbtHexs:t,options:e}){let n=await this.getOkxConnectProvider(),a=this.chainMethodMap(this.chainType).signPsbts;if(!a)throw new Error("current chain have no signPsbts, please check it");return await a({psbtHexs:t,options:e,provider:n})}async pushPsbt({psbtHex:t}){let e=await this.getOkxConnectProvider(),n=this.chainMethodMap(this.chainType).pushPsbt;if(!n)throw new Error("current chain have no sendPsbt, please check it");return await n({provider:e,psbtHex:t})}async validateAddress({account:t}){let e=await this.getOkxConnectProvider(),n=this.chainMethodMap(this.chainType).validateAddress;if(!n)throw new Error("current chain have no validateAddress, please check it");return await n({provider:e,account:t})}async sendBitcoin({to:t,value:e,satBytes:n,extraParams:a,...r}){let s=await this.getOkxConnectProvider(),o=await this.getAccount(),c=this.chainMethodMap(this.chainType).sendBitcoin;if(!c)throw new Error("current chain have no sendBitcoin, please check it");return await c({provider:s,from:o,to:t,value:e,satBytes:n,extraParams:a,...r})}async getBtcAddressType({address:t}){let e=this.chainMethodMap(this.chainType).getBtcAddressType;if(!e)throw new Error("current chain have no sendInscription, please check it");return e({address:t})}async inscribe({from:t,to:e,txSource:n,type:a,inscriptions:r,tick:s,amount:o,mintType:c,...u}){let h=await this.getOkxConnectProvider(),d=this.chainMethodMap(this.chainType).inscribe;if(!d)throw new Error("current chain have no sendInscription, please check it");return d({provider:h,from:t,to:e,txSource:n,type:a,inscriptions:r,tick:s,amount:o,mintType:c,...u})}};export{A as OkxConnectAdapter};
//# sourceMappingURL=OkxConnectAdapter-WD22XIJD.js.map
