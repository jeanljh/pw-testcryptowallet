import{a as l}from"./chunk-KBE37TKW.js";import{a as E}from"./chunk-YYPH76BH.js";import{c as h,f as T}from"./chunk-25RXMKCK.js";import"./chunk-YS3HYG35.js";import{d as A,e as S}from"./chunk-GVNSNU7P.js";import"./chunk-N3AWCE75.js";import{a as u,b as e,c as f}from"./chunk-MVO3PFGF.js";import"./chunk-DKCWR6P4.js";import"./chunk-AEGO4G2O.js";import"./chunk-7BSXWXHJ.js";import{o as g,q as C}from"./chunk-4J7XGGEQ.js";g();C();var M=class extends E{constructor({supportChain:t}){super(),this.chainType=e.EVM,this.chainMap={},this.supportChain=t&&t.length>0?t:[e.EVM,e.SOLANA,e.APTOS,e.TRON,e.SUI,e.BTC,e.FRACTAL,e.BTCSIGNET,e.BTCTESTNET,e.STACKS,e.STARKNET,e.NOSTR,e.COSMOS,e.TON,e.SONIC_DEV,e.SOON,e.ECLIPSE],this.initPromise=this.init(),this.aptos={},this.btc={},this.fractal={},this.cosmos={}}async getWeb3(){let t=await this.getOkxWalletProvider();return this.chainType===e.EVM?t:window?.okexchain[f[this.chainType]]}async init(){let t=this.supportChain.includes(e.SOLANA)?(await import("./Solana-CNSYDZ7Y.js")).default:{},n=this.supportChain.includes(e.APTOS)?(await import("./Aptos-UP44HOG5.js")).default:{},i=this.supportChain.includes(e.TRON)?(await import("./Tron-PUOFTFE7.js")).default:{},a=this.supportChain.includes(e.SUI)?(await import("./Sui-GGPMAATL.js")).default:{},c=this.supportChain.includes(e.BTC)?(await import("./Btc-NVKJUDKR.js")).default:{},s=this.supportChain.includes(e.FRACTAL)?(await import("./Fractal-XPEFK4WD.js")).default:{},r=this.supportChain.includes(e.BTCSIGNET)?(await import("./BtcSignet-TP7W3RAH.js")).default:{},o=this.supportChain.includes(e.BTCTESTNET)?(await import("./BtcTestnet-AB2WHBNA.js")).default:{},p=this.supportChain.includes(e.STACKS)?(await import("./Stacks-VDFEF7F7.js")).default:{},d=this.supportChain.includes(e.STARKNET)?(await import("./Starknet-IK64YQ5H.js")).default:{},w=this.supportChain.includes(e.NOSTR)?(await import("./Nostr-ADRMLGVB.js")).default:{},y=this.supportChain.includes(e.COSMOS)?(await import("./Cosmos-FZGJFKVY.js")).default:{},v=this.supportChain.includes(e.TON)?(await import("./Ton-TH4COLSW.js")).default:{},m=this.supportChain.includes(e.SONIC_DEV)?(await import("./SonicDev-BP2ZCCNJ.js")).default:{},O=this.supportChain.includes(e.SOON)?(await import("./Soon-2BF6XEW4.js")).default:{},k=this.supportChain.includes(e.ECLIPSE)?(await import("./Eclipse-XB3KOQHE.js")).default:{};this.chainMap={[e.SOLANA]:{...t},[e.APTOS]:{...n},[e.TRON]:{...i},[e.SUI]:{...a},[e.BTC]:{...c},[e.FRACTAL]:{...s},[e.BTCSIGNET]:{...r},[e.BTCTESTNET]:{...o},[e.STACKS]:{...p},[e.STARKNET]:{...d},[e.NOSTR]:{...w},[e.TON]:{...v},[e.SONIC_DEV]:{...m},[e.COSMOS]:y,[e.SOON]:O,[e.ECLIPSE]:k},this.aptos=n,this.btc=c,this.fractal=s,this.cosmos=y}chainMethodMap(t){return this.chainMap[t]||{...l}}async getOkxWalletProvider(){let t=await h({chainType:this.chainType});if(this.chainType===e.EVM){let{web3Provider:n}=t;return n}return t}async getAccount({isNeedAll:t}={}){let n=await h();try{let i=await n?.getAccounts();if(t){let r=[];return i.forEach(o=>{let{address:p}=o;r.push(p)}),[...new Set(r)].join(",")}let a=this.chainMethodMap(this.chainType).getAccount,c=await this.getOkxWalletProvider(),s=await a({provider:c});if(!s)try{if(i&&i.length>0)return i[0].address}catch(r){throw console.log("get address err:",r),r}return s}catch(i){console.log("get address err:",i);try{let a=[];if(n?.getAccounts&&(a=await n?.getAccounts()),a&&a.length>0)return a[0].address}catch(a){throw console.log("get address err:",a),a}}}async getAccountByChainId({chainId:t,chainType:n}){let i=n||n===0?n:T(t),a=this.chainMethodMap(i).getAccount,c=await h({chainType:i});i===e.EVM&&(c=c?.web3Provider);try{return await a({provider:c,chainId:t})}catch(s){return console.log("getAccountByChainId err:",s),""}}async signMessage({nonce:t,message:n}){let i=await this.getOkxWalletProvider(),a=await this.getAccount(),c=this.chainMethodMap(this.chainType).signMessage;try{return await c({provider:i,message:n,nonce:t,address:a})}catch(s){throw console.log("signMessage err:",s),s}}async signTypedData({message:t,...n}){let i=await this.getAccount();return await window?.okexchain?.request({method:"eth_signTypedData_v4",params:[i,JSON.stringify(t)],...n})}async getChainId(){if(this.chainType===e.EVM){let t=await this.getOkxWalletProvider(),n=await l.getChainId({provider:t});return await S(n)}else if(this.chainType===e.COSMOS)return this.cosmos.getChainId();return this.chainType}async onChainChange(t){window?.okxwallet?.on?.("chainChanged",t)}async switchNetwork({chain:t,chainType:n,addNetworkConfig:i}){let a=await this.getChainId(),c=await this.getAccountByChainId({chainId:t,chainType:n}),s=n||n==0?n:T(t);if(c){if(s!==e.EVM)return!0}else return!1;let r=await A(t);if(a===r||isNaN(r))return!0;try{return await window?.okexchain?.switchChain({chainId:`0x${Number(r).toString(16)}`}),!0}catch(o){if(o.code===4902)try{return await window?.okexchain?.request({method:"wallet_addEthereumChain",params:i}),!0}catch{return!1}return!1}}async watchAsset({tokenOptions:t}){let n=window.okexchain;return await l.watchAsset({provider:n,tokenOptions:t})}async sendTransaction({payload:t,cb:n,extraParams:i}){let a=await this.getOkxWalletProvider(),c=this.chainMethodMap(this.chainType).sendTransaction,s=await this.getAccount();return c({provider:a,payload:t,cb:n,extraParams:i,address:s})}async setChainType({chainType:t,chainId:n}){let i=t||t==0?t:T(n);if(!!await this.getAccountByChainId({chainId:n,chainType:i}))this.chainType=i,i===e.COSMOS&&this.cosmos.setChainId(n);else{let s=await h();s?.getAccounts?s.getAccounts().then(r=>{if(r){let{coinType:o}=r[0];this.chainType=o}}).catch(()=>{this.chainType=i}):this.chainType=i}}async signAllTransactions({transactions:t}){let n=await this.getOkxWalletProvider(),i=this.chainMethodMap(this.chainType).signAllTransactions;if(!i)throw new Error("current chain have no signAllTransactions, please check it");return await i({provider:n,transactions:t})}async depositWToken({wTokenAddr:t,wTokenAbi:n,amount:i,cb:a}){let c=await this.getAccount(),s=await this.getWeb3(),r=l.depositWToken({wTokenAddr:t,wTokenAbi:n,amount:i,account:c,web3:s});return this.sendTransaction({payload:r,cb:a})}async withdrawWToken({wTokenAddr:t,wTokenAbi:n,amount:i,cb:a}){let c=await this.getAccount(),s=await this.getWeb3(),r=l.withdrawWToken({wTokenAddr:t,wTokenAbi:n,amount:i,account:c,web3:s});return this.sendTransaction({payload:r,cb:a})}async getAllChainTypeInfoList(){let t=[],i=await(await h())?.getAccounts();if(i&&i.length>0){let a={[u.ETH]:e.EVM,[u.FRACTAL]:e.FRACTAL,[u.BTCTESTNET]:e.BTCTESTNET,[u.SONIC_DEV]:e.SONIC_DEV,[u.SOON]:e.SOON,[u.ECLIPSE]:e.ECLIPSE},c=[];i.forEach(o=>{let{chainId:p}=o,d=a[Number(p)];d&&c.push({...o,chainType:d})});let s=i.filter(o=>{let{coinType:p,chainId:d}=o;return p!==e.EVM&&!Object.keys(a).includes(String(d))}),r=new Map;t=s.filter(o=>!r.has(o.coinType)&&r.set(o.coinType,1)),t=t.map(o=>({...o,chainType:o.coinType})),t.push(...c)}return t}async registerAptosCoin({contractAddress:t}){return this.aptos.registerAptosCoin({contractAddress:t,provider:window.okexchain})}async checkAndRegAptosCoin({address:t,contractAddress:n}){return this.aptos.checkAndRegAptosCoin({provider:window.okexchain,address:t,contractAddress:n})}async getAptosBalance({address:t,currency:n}){return this.aptos.getAptosBalance({address:t,currency:n})}async getAptosTransaction(t){return this.aptos.getAptosTransaction(t)}getSolanaConnection(){let t=this.chainMethodMap(this.chainType).getSolanaConnection;if(!t)throw new Error("current chain have no getSolanaConnection, please check it");return t()}async getPublicKey(){let t=await this.getOkxWalletProvider(),n=this.chainMethodMap(this.chainType).getPublicKey;if(!n)throw new Error("current chain have no getPublicKey, please check it");return n({provider:t})}async getCompressedPublicKey(){let t=await this.getOkxWalletProvider(),n=this.chainMethodMap(this.chainType).getCompressedPublicKey;if(!n)throw new Error("current chain have no getCompressedPublicKey, please check it");return n({provider:t})}async sendInscription({from:t,to:n,data:i,type:a}){let c=await h({chainType:this.chainType}),s=this.chainMethodMap(this.chainType).sendInscription;if(!s)throw new Error("current chain have no sendInscription, please check it");return await s({provider:c,from:t,to:n,data:i,type:a})}async signPsbt({psbtHex:t,type:n,...i}){let a=await h({chainType:this.chainType}),c=await this.getAccount(),s=this.chainMethodMap(this.chainType).signPsbt;if(!s)throw new Error("current chain have no signPsbt, please check it");return s({provider:a,psbtHex:t,type:n,account:c,...i})}async sendPsbt({txList:t}){let n=await h({chainType:this.chainType}),i=await this.getAccount(),a=this.chainMethodMap(this.chainType).sendPsbt;if(!a)throw new Error("current chain have no sendPsbt, please check it");return await a({provider:n,txList:t,account:i})}async pushPsbt({psbtHex:t}){let n=await h({chainType:this.chainType}),i=this.chainMethodMap(this.chainType).pushPsbt;if(!i)throw new Error("current chain have no sendPsbt, please check it");return await i({provider:n,psbtHex:t})}async signPsbts({psbtHexs:t,options:n}){let i=await h({chainType:this.chainType}),a=this.chainMethodMap(this.chainType).signPsbts;if(!a)throw new Error("current chain have no signPsbts, please check it");return await a({psbtHexs:t,options:n,provider:i})}async validateAddress({account:t}){let n=await h({chainType:this.chainType}),i=this.chainMethodMap(this.chainType).validateAddress;if(!i)throw new Error("current chain have no validateAddress, please check it");return await i({provider:n,account:t})}async sendBitcoin({to:t,value:n,satBytes:i,extraParams:a,...c}){let s=await h({chainType:this.chainType}),r=await this.getAccount(),o=this.chainMethodMap(this.chainType).sendBitcoin;if(!o)throw new Error("current chain have no sendBitcoin, please check it");return await o({provider:s,from:r,to:t,value:n,satBytes:i,extraParams:a,...c})}async getLatestBlockhash(){let t=await this.getAccount(),n=this.chainMethodMap(this.chainType).getLatestBlockhash;if(!n)throw new Error("current chain have no getLatestBlockhash, please check it");return await n({from:t})}async getBtcAddressType({address:t}){let n=this.chainMethodMap(this.chainType).getBtcAddressType;if(!n)throw new Error("current chain have no sendInscription, please check it");return n({address:t})}async inscribe({from:t,to:n,txSource:i,type:a,inscriptions:c,tick:s,amount:r,mintType:o,...p}){let d=await h({chainType:this.chainType}),w=this.chainMethodMap(this.chainType).inscribe;if(!w)throw new Error("current chain have no sendInscription, please check it");return w({provider:d,from:t,to:n,txSource:i,type:a,inscriptions:c,tick:s,amount:r,mintType:o,...p})}};export{M as OkxWalletAdapter};
//# sourceMappingURL=OkxWalletAdapter-MDZYPTFZ.js.map
