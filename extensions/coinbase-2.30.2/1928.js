"use strict";(self.webpackChunkcb_wallet_extension=self.webpackChunkcb_wallet_extension||[]).push([[1928],{41928:(e,s,r)=>{r.r(s),r.d(s,{ETHEREUM_MESSAGE_PREFIX:()=>g,Message:()=>o,signEthereumMessage:()=>l,ethereumAddressFromSignedMessage:()=>h});var n=r(51299),t=r(87554),i=r(65866),c=r(48834).Buffer;const a=new t.ec("secp256k1"),g=c.from("\x19Ethereum Signed Message:\n","utf8");class o{_message;_prefix=null;constructor(e,s=g){this._message=e,this._prefix=s}get message(){return this._message}get prefixedMessage(){return this._prefix?(0,n.wn)(c.concat([this._prefix,c.from(String(this._message.length),"utf8"),this._message])):this._message}sign(e){const s=a.keyFromPrivate(e).sign(this.prefixedMessage,{canonical:!0}),r=c.alloc(65);let t=0;const i=(0,n.Qe)(s.r);t+=32-i.length,t+=i.copy(r,t);const g=(0,n.Qe)(s.s);return t+=32-g.length,t+=g.copy(r,t),r.writeUInt8((s.recoveryParam??0)+27,t),r}ecRecover(e){if(65!==e.length)throw new Error("Invalid signature");const s=e[e.length-1]-27,r={r:e.slice(0,32),s:e.slice(32,64)},n=a.recoverPubKey(this.prefixedMessage,r,s),t=c.from(n.encode("hex",!0),"hex");return i.Address.from(t).address}}function l(e,s,r=!0){return(r?new o(e):new o(e,null)).sign(s)}function h(e,s,r=!0){return(r?new o(e):new o(e,null)).ecRecover(s)}}}]);
//# sourceMappingURL=1928.js.map