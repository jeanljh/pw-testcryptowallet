import{a as nt}from"./chunk-5HTF5CEZ.js";import{Za as ot,w as H}from"./chunk-COS4XKZ5.js";import{a as tt,b as et}from"./chunk-IJLITZAC.js";import{Ac as X,Jb as B,M as A,Pb as v,W as Y,X as P,Ya as J,nd as z,pa as w,qa as _,ub as Q,xc as Z}from"./chunk-GSVPXWLR.js";import{a as k,r as F}from"./chunk-LYTSCHVN.js";import{h as G,k as q}from"./chunk-P5BPG5MC.js";import{z as V}from"./chunk-PPQ6BNOX.js";import{a as i,g as $,i as h,m as Buffer,n as y}from"./chunk-NSVULBS3.js";h();y();h();y();var m=$(k());h();y();var U=i(t=>t.reduce((e,o)=>{let n=e;for(let c of o.accounts){let s=c.chain.name.toLowerCase();if(e[s]?.balance&&e[s]?.history)continue;let d="amount"in c?parseFloat(c.amount)>0:!1,a=c.hasAccountActivity;if(!e[s]){n={...n,[s]:{balance:d,history:a}};continue}n={...n,[s]:{...n[s],balance:d||n[s]?.balance,history:a||n[s]?.history}}}return n},{}),"generateImportedAccountChainAnalytics");h();y();h();y();var At="/discover/v1",gt={Accept:"application/json"},vt=i(t=>{if(!t||!Array.isArray(t.accounts))return!1;for(let e of t.accounts)if(!(typeof e.address=="string"&&typeof e.amount=="string"&&(!e.lastActivityTimestamp||typeof e.lastActivityTimestamp=="number")&&e.chain&&typeof e.chain.id=="string"&&new Set(v.getAllNetworkIDs()).has(e.chain.id)&&typeof e.chain.name=="string"&&typeof e.chain.symbol=="string"&&typeof e.chain.imageUrl=="string"))return!1;return!0},"isDiscoveryAccountResponse"),St=i(t=>!!t&&typeof t.message=="string","isErrorResponse"),L=i(async t=>{if(!t.accounts.length)throw new Error("Must send at least 1 account for discovery");let e=await G.api().noBearer().headers(gt).post(At,t),o=e.data;if(!q(e))throw St(o)?new Error(o.message):new Error(`Unable to discover accounts with args: ${JSON.stringify(t)}`);if(vt(o))return o;throw new Error(`Invalid discover accounts response: ${JSON.stringify(o)}`)},"fetchDiscoverAccounts");var Tt="fetch-multi-chain-accounts-by-seed",Pt=i(()=>[A.BitcoinTaproot,A.BitcoinNativeSegwit],"orderedBitcoinDerivationPathTypes"),It=i(()=>[A.Bip44ChangeSolana,A.Bip44Solana,A.DeprecatedSolana],"orderedSolanaDerivationPathTypes"),Dt=i(()=>[A.Bip44Ethereum,A.Bip44EthereumSecondary,A.Bip44EthereumTertiary],"orderedEVMDerivationPathTypes"),Et=i(()=>[A.Bip44Sui],"orderedSuiDerivationPathTypes"),xt=i((t,e)=>Pt().map(o=>{let n={pathType:o,index:t},{publicKey:c}=e.derivePathType(o,t),s=_.getAddressType(o),d=B({publicKey:c,addressType:s});return{chainType:s,chainId:w.Bitcoin.Mainnet,address:d,publicKey:Buffer.from(c).toString("hex"),pathParams:n}}),"derivedBitcoinAccounts"),bt=i((t,e)=>Dt().map(o=>{let n={pathType:o,index:t},{publicKey:c}=e.derivePathType(o,t),s=_.getAddressType(o),d=B({publicKey:c,addressType:P.EVM});return{chainType:s,pathType:o,address:d,publicKey:Buffer.from(c).toString("hex"),pathParams:n}}),"derivedEVMAccounts"),Ot=i((t,e)=>It().map(o=>{let n={pathType:o,index:t},c=e.derivePathType(o,t),s;switch(o){case A.Bip44RootSolana:case A.Bip44Solana:case A.Bip44ChangeSolana:s=c.publicKey;break;case A.DeprecatedSolana:s=J(c.secretKey).publicKey;break}let d=B({publicKey:s,addressType:P.Solana});return{chainType:P.Solana,chainId:w.Solana.Mainnet,address:d,publicKey:Buffer.from(s).toString("hex"),pathParams:n}}),"derivedSolanaAccounts"),wt=i((t,e)=>Et().map(o=>{let n={pathType:o,index:t},{publicKey:c}=e.derivePathType(o,t),s=B({publicKey:c,addressType:P.Sui});return{chainType:P.Sui,chainId:w.Sui.Mainnet,address:s,publicKey:Q(c),pathParams:n}}),"derivedSuiAccounts"),Bt=1e4,ct=i(async(t,e=!0)=>{let o=Object.assign({},...t);try{let n=Object.values(o).map(({account:u})=>({address:u.address,chainId:u.chainId})),c;e?c=(await et(async()=>nt(L({accounts:n}),Bt),()=>!0,2)).accounts:c=(await L({accounts:n})).accounts;let s={};for(let u of c){let{account:p}=o[`${u.chain.id}-${u.address}`],g=p.publicKey,S=p.chainType,T=H(p.pathParams),D={...u,publicKey:g,chainType:S,derivationPathType:p.pathParams.pathType,hasAccountActivity:!!u.lastActivityTimestamp||parseFloat(u.amount)>0};s[T]=[...s[T]||[],D]}Object.keys(s).forEach(u=>{s[u]=s[u].sort((p,g)=>v.compareNetworkID(p.chain.id,g.chain.id))});let d=Object.values(s),a=d.filter(u=>u.some(p=>p.hasAccountActivity)),r=!!a.length;return(r?a:d).map(u=>{let p=u[0];return{status:"discovered",seedIndex:o[`${p.chain.id}-${p.address}`].account.pathParams.index??-1,isSelectedByDefault:r,accounts:u}})}catch{let n=Object.values(o).map(({account:a})=>a),c={};for(let a of n){let{account:r}=o[`${a.chainId}-${a.address}`],l=H(r.pathParams),f={...a,chain:{id:a.chainId,name:v.getNetworkName(a.chainId),symbol:v.getTokenSymbol(a.chainId)},chainType:_.getAddressType(r.pathParams.pathType),derivationPathType:r.pathParams.pathType,hasAccountActivity:!1};c[l]=[...c[l]||[],f]}return Object.keys(c).forEach(a=>{c[a]=c[a].sort((r,l)=>v.compareNetworkID(r.chain.id,l.chain.id))}),Object.values(c).map(a=>{let r=a[0];return{status:"undiscovered",seedIndex:o[`${r.chain.id}-${r.address}`].account.pathParams.index??-1,accounts:a,isSelectedByDefault:!1}})}},"discoverAccounts"),Mt=i(async({hdWallet:t,startIndex:e,endIndex:o,enabledAddressTypes:n,enabledChains:c})=>{let s=[];for(let d=e;d<=o;++d){let a={};if(n.includes(P.BitcoinNativeSegwit))for(let r of xt(d,t))a[`${w.Bitcoin.Mainnet}-${r.address}`]={account:r};if(n.includes(P.EVM)){let r=bt(d,t),l=c.filter(f=>v.isEVMNetworkID(v[f].mainnetID));for(let f of l){let u=v[f];for(let{address:p,publicKey:g,chainType:S,pathParams:T}of r)a[`${u.mainnetID}-${p}`]={account:{chainType:S,chainId:u.mainnetID,address:p,publicKey:g,pathParams:T}}}}if(n.includes(P.Solana))for(let r of Ot(d,t))a[`${r.chainId}-${r.address}`]={account:r};if(n.includes(P.Sui))for(let r of wt(d,t))a[`${r.chainId}-${r.address}`]={account:r};s.push(a)}return ct(s)},"discoverAccountsBySeed");function W({batchSize:t,hdWallet:e,enabledAddressTypes:o,enabledChains:n}){let c=!!e&&o.length!=0;return z({enabled:c,queryKey:[Tt,t],queryFn:i(async({pageParam:r=0})=>{try{if(t<1)throw new Error(`Need positive batchSize: ${t}`);if(!e)throw new Error("Missing HDWallet");let l=[],f=[],u=r===0,p=r,g=!0;for(;g;){let S=p,T=p+t-1,I=(await Mt({hdWallet:e,startIndex:S,endIndex:T,enabledAddressTypes:o,enabledChains:n})).flat(1);p+=t,g=!1;for(let E of I)l.push(E),(E.status==="undiscovered"||E.isSelectedByDefault)&&f.push(E),u&&E.status==="discovered"&&E.isSelectedByDefault&&(g=!0)}if(u&&f.length===0&&l.length>1){let S=l[0],T=S.accounts.map(I=>({...I,hasAccountActivity:!1})),D={status:"undiscovered",seedIndex:S.seedIndex,accounts:T,isSelectedByDefault:!1};f.push(D)}return f}catch(l){throw l instanceof Error&&X.captureError(l,Z.Account),l}},"queryFn"),getNextPageParam:i((r,l)=>{let f=l.length,u=f?l[0]:[],p=u.length?Ct(u[u.length-1].seedIndex,t):0;return f===1?p:p+t*(f-1)},"getNextPageParam"),gcTime:0,staleTime:0,initialPageParam:0})}i(W,"useDiscoverMultiChainAccounts");var Ct=i((t,e)=>Math.ceil(t/e)*e+e,"roundUpByBatchSize");h();y();var N=$(k());var st=i(t=>{let e=ot(),o=(0,N.useCallback)(n=>e.includes(v.getChainID(n.chain.id)),[e]);return(0,N.useMemo)(()=>t?t.map(n=>n.status==="undiscovered"?{...n,accounts:n.accounts.filter(c=>o(c))}:{...n,accounts:n.accounts.filter(c=>o(c)&&c.hasAccountActivity)}):[],[o,t])},"useActiveAccounts");h();y();var K=$(k());var rt=i(t=>{let[e,o]=(0,K.useState)(null);return(0,K.useEffect)(()=>{if(t.length){let n=new Y(t);return o(n),()=>{o(null),n.cleanup()}}},[t]),e},"useCachedHDWallet");var _t=i(t=>(0,m.useMemo)(()=>t.reduce((e,o,n)=>(e[n]=n===0||o.isSelectedByDefault,e),{}),[t]),"useDefaultSelectedAccounts"),Ft=i((t,e)=>(0,m.useMemo)(()=>t?.reduce((o,n,c)=>e[c]?[...o,n]:o,[])??[],[t,e]),"useSelectedAccounts"),Nt=i((t,e)=>{(0,m.useEffect)(()=>{e(o=>{let{length:n}=Object.keys(t),c={};for(let s=0;s<n;s++)c[s]=o[s]===void 0?t[s]:o[s];return c})},[t,e])},"useEffectUpdateSelectedAccounts"),Kt=3e3,Rt=i((t,e)=>{let{t:o}=F();return(0,m.useEffect)(()=>{let n;if(t){let{pages:c}=t,s=c.length>1,d=c[c.length-1].length===0;s&&d&&(e(o("onboardingSelectAccountsFindMoreNoneFound")),n=setTimeout(()=>{e(o("onboardingSelectAccountsFindMoreAccounts"))},Kt))}return()=>{n&&clearTimeout(n)}},[t])},"useEffectFindMoreAccountsButtonText"),$t=i(({activeAccountsNumber:t,allAccountsNumber:e,hasDiscoveryFailed:o})=>{let{t:n}=F(),c=t>0&&!o;return(0,m.useMemo)(()=>e===0?n("onboardingImportImportingFindingAccounts"):t===0?n("onboardingImportAccountsEmptyResult"):e===1?c?n("onboardingImportAccountsFoundAccounts_one",{numberOfWallets:t}):n("onboardingImportAccountsFoundAccountsNoActivity_one",{numberOfWallets:e}):e>1?c?n("onboardingImportAccountsFoundAccounts_other",{numberOfWallets:t}):n("onboardingImportAccountsFoundAccountsNoActivity_other",{numberOfWallets:e}):"",[t,e,c,n])},"useSubtitle"),at={extension:7,ios:7,android:7,web:7},kt=i(({seed:t,navigationCallback:e,storageCallback:o,enabledAddressTypes:n,enabledChains:c})=>{let{t:s}=F(),d=s("onboardingSelectAccountsFindMoreAccounts"),[a,r]=(0,m.useState)({}),[l,f]=(0,m.useState)(!1),[u,p]=(0,m.useState)(!1),[g,S]=(0,m.useState)(d),T=rt(t),{data:D,status:I,fetchNextPage:E,isFetchingNextPage:it}=W({batchSize:at[V],hdWallet:T,enabledAddressTypes:n,enabledChains:c}),M=(0,m.useMemo)(()=>D?.pages.flat()??[],[D]),R=st(M),ut=_t(R),O=Ft(M,a),dt=$t({activeAccountsNumber:R.length,allAccountsNumber:M.length,hasDiscoveryFailed:M[0]?.status==="undiscovered"});Rt(D,S),Nt(ut,r);let lt=(0,m.useCallback)(()=>p(!0),[]),pt=(0,m.useCallback)(C=>{if(I!=="success")return;let x={...a};x[C]=!x[C],r(x)},[I,a,r]),ft=(0,m.useCallback)(()=>{I==="success"&&r(C=>{let x={...C},ht=Object.values(x).every(Boolean);return Object.keys(x).forEach((Ht,yt)=>{x[yt]=!ht}),x})},[I,r]),mt=(0,m.useCallback)(async()=>{l||(f(!0),await tt(0),await o(O,U(O)),f(!1),e(U(O)))},[l,O,e,o]),j={expanded:u,findMoreAccountsButtonText:g,isFetchingMoreAccounts:it,isImporting:l,renderedPages:R,selectedAccounts:a,subtitle:dt,findMoreAccounts:E,onExpand:lt,onImport:mt,onSelect:pt,onSelectAll:ft};return I!=="success"?{status:"loading",isImportButtonDisabled:!0,...j}:{status:"success",isImportButtonDisabled:O.length===0,...j}},"useSelectMultichainAccountsProps");export{ct as a,at as b,kt as c};
//# sourceMappingURL=chunk-RJFXEHIV.js.map
